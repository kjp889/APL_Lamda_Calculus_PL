you are tasked with writing the yacc file for a simple lambda calculus compiler, you are to use 
"%{
#include <stdio.h>
#include "y.tab.h"
%}

%%
[a-z]       {yylval=yytext[0]; return VAR;}
[a-z0-9]+   {yylval=yytext; return NAME;}
#           return LAMBDATKN;
\(          return OBRACETKN;
\)          return CBRACETKN;
\+          return PLUSTKN;
\-          return MINUSTKN;
\*          return TIMESTKN;
\/          return DIVIDETKN;
\.          return DOTTKN;
\n          //return NEWLINETKN;
[ \t]+      /* ignore whitespace */;
%%"
as the lex file for the lexical analyzer and a simple lambda calculus grammar as the grammar for the yacc file. your file should be fully commented so that a novice can read the program and understand what the yacc file is doing.

%{
// Include standard input/output library for printing
#include <stdio.h>

// Include header file generated by yacc (usually named y.tab.h)
// This header contains definitions of token types (e.g., VAR, LAMBDATKN)
#include "y.tab.h"
%}

%%

/* 
  This section defines patterns (regular expressions) for tokens 
  and the corresponding actions to be taken when a match is found.
*/

/* Single lowercase letter - represents a variable */
[a-z] { yylval = yytext[0]; return VAR; }

/* One or more alphanumeric characters - represents a name (potentially a function name) */
[a-z0-9]+ { yylval = yytext; return NAME; }

/* Keyword 'lambda' - represents lambda abstraction */
# { return LAMBDATKN; }  // "#" matches the literal character '#'

/* Opening parenthesis */
\( { return OBRACETKN; }

/* Closing parenthesis */
\) { return CBRACETKN; }

/* Plus symbol */
\+ { return PLUSTKN; }

/* Minus symbol */
\- { return MINUSTKN; }

/* Multiplication symbol */
\* { return TIMESTKN; }

/* Division symbol */
\/ { return DIVIDETKN; }

/* Dot symbol */
\. { return DOTTKN; }

/* Newline character - currently ignored (can be used for error handling later) */
// \n  { return NEWLINETKN; }

/* Whitespace characters (space and tab) - ignored */
[ \t]+  /* ignore whitespace */

/* 
  This section defines the grammar rules for lambda calculus expressions.
  Each rule has a left-hand side (LHS) which represents a non-terminal symbol
  and a right-hand side (RHS) which is a combination of terminals (tokens) 
  and non-terminal symbols. The actions within curly braces are executed
  when the corresponding rule is matched.
*/

/* 
  Program: represents the entire lambda calculus program.
  It can be a single expression. (corrected the typo here)
*/
program: expr  { printf("Valid lambda calculus expression.\n"); }
             ; 

/* 
  Expression: the most generic rule for any lambda calculus expression.
  It can be a variable, an application of two expressions, or a lambda abstraction.
*/
expr: VAR     { /* variable */ }
    | NAME    { /* function name */ }
    | '(' expr ')' { /* parenthesized expression for grouping */ }
    | expr expr  { /* application of two expressions */ }
    | lambda    { /* lambda abstraction */ }
    ;

/* 
  Lambda abstraction: defines the structure of a lambda expression.
  It starts with the keyword 'lambda', followed by a variable name, 
  a dot ('.') to separate the argument from the body, and finally the body expression.
*/
lambda: '#' VAR '.' expr { return yylval = mk_lambda(yytext[0], $4); } 
        ;

%%

int yyerror(const char *s) {
  fprintf(stderr, "Error: %s\n", s);
  return 1;
}
